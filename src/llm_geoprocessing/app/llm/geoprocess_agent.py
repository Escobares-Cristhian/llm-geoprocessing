import json
import re
from typing import Dict, Any, List, Optional

from llm_geoprocessing.app.chatbot.chatbot import Chatbot

    
# ---------------------------------
# ----- JSON Completion Logic -----
# ---------------------------------

import json
import re
from typing import Optional, Dict, Any, List

# NOTE: Assumes a Chatbot() class is available in your environment.
# from your_llm_client import Chatbot


def _schema_instructions() -> str:
    # Strict schema + rules (concise)
    return (
        "Return ONLY a JSON wrapper with keys: 'json', 'complete', 'questions'.\n"
        "- 'json' keys:\n"
        "  1) 'products': object mapping product IDs ('A','B',...) to objects with:\n"
        "     - 'name': string (product name, e.g., '<satellite>_<product>'; satellite may be 'ANY').\n"
        "     - 'date': {'initial_date':'YYYY-MM-DD','end_date':'YYYY-MM-DD',"
        "     - 'proj': string (use 'default' to keep original).\n"
        "     - 'res': float OR the string 'NaN' to keep original.\n"
        "  2) 'actions': list of 2-item lists: ['recortar', <string>] and ['algorithm', <string>]. "
        "     'recortar' value: a shapefile name (no path) OR a bbox string like "
        "     '[x_min, y_min, x_max, y_max], geodesic=True/False' OR 'no'. "
        "     'algorithm' value: 'no' OR a formula starting with '=' using product IDs "
        "     (e.g., '=(A-B)/(A+B)'). If user wrote 'equation', treat as 'algorithm'.\n"
        "  3) 'other_params': dict (can be {}).\n"
        "Never invent values. If unknown, leave missing and add precise questions.\n"
        "Wrapper format:\n"
        "{ 'json': {...}, 'complete': true|false, 'questions': ['Q1','Q2',...] }\n"
    )


def _sanitize_json(raw: str) -> str:
    # Replace bare NaN -> "NaN"; remove trailing commas
    s = re.sub(r'(?<!\")\bNaN\b(?!\")', '"NaN"', raw)
    s = re.sub(r",\s*([}\]])", r"\1", s)
    return s


def _extract_first_json_block(text: str) -> Optional[Dict[str, Any]]:
    # Prefer fenced code blocks
    blocks = re.findall(r"```(?:json)?\s*(\{[\s\S]*?\})\s*```", text, flags=re.IGNORECASE)
    if not blocks:
        blocks = re.findall(r"(\{[\s\S]*\})", text)
    for b in blocks:
        try:
            return json.loads(_sanitize_json(b))
        except Exception:
            continue
    return None


def complete_json(user_message: str) -> Dict[str, Any]:
    """
    Build the target JSON by dialog with the user via the LLM.
    - Input: single pre-processed message (string).
    - Flow: extract -> if missing, ask -> update -> repeat.
    - Output: Python dict with the requested schema.
    - All user-facing messages are generated by the LLM (printed).
    """
    chat = Chatbot()
    MAX_TURNS = 8  # tiny safety to avoid infinite loops

    # 1) Ask LLM to extract from the initial message
    prompt = (
        "Task: Extract everything you can from the user's message into the schema. "
        "List only the truly missing items as questions.\n\n"
        f"User message:\n{user_message}\n\n{_schema_instructions()}"
    )
    reply = chat.send_message(prompt)
    wrapper = _extract_first_json_block(reply)
    if not wrapper or not all(k in wrapper for k in ("json", "complete", "questions")):
        raise ValueError("LLM did not return a valid wrapper JSON on first pass.")

    state: Dict[str, Any] = wrapper["json"]
    complete: bool = bool(wrapper["complete"])
    questions: List[str] = list(wrapper.get("questions", []))

    # 2) If incomplete, iterate: ask -> wait -> update
    turns = 0
    while not complete and turns < MAX_TURNS:
        turns += 1

        # LLM composes the concise questions to show the user
        q_prompt = (
            "Compose a single concise message asking ONLY these questions, nothing else.\n"
            + "\n".join(f"{i+1}. {q}" for i, q in enumerate(questions))
            + "\n Respond in the same language as the user."
        )
        q_msg = chat.send_message(q_prompt)
        print(q_msg)  # show LLM's question to the user

        user_answer = input("You: ").strip()
        if user_answer.lower() in {"exit", "quit"}:
            raise KeyboardInterrupt("User aborted.")

        # Ask LLM to update the JSON with the user's answers
        update_prompt = (
            "Update the JSON with the user's answers. Keep confirmed fields. "
            "Ask follow-ups only if still missing.\n\n"
            f"Current JSON:\n```json\n{json.dumps(state, ensure_ascii=False)}\n```\n\n"
            f"User reply:\n{user_answer}\n\n{_schema_instructions()}"
        )
        reply = chat.send_message(update_prompt)
        wrapper = _extract_first_json_block(reply)
        if not wrapper or not all(k in wrapper for k in ("json", "complete", "questions")):
            raise ValueError("LLM did not return a valid wrapper JSON during update.")

        state = wrapper["json"]
        complete = bool(wrapper["complete"])
        questions = list(wrapper.get("questions", []))

    # 3) Minimal shape checks (simple and strict)
    required = ["products", "actions", "other_params"]  # per-product date/proj/res now nested
    if not all(k in state for k in required):
        raise ValueError("Final JSON missing required keys.")
    if not isinstance(state["products"], dict):
        raise ValueError("'products' must be a dict.")
    if not isinstance(state["actions"], list):
        raise ValueError("'actions' must be a list.")
    if not isinstance(state["other_params"], dict):
        raise ValueError("'other_params' must be a dict.")

    # Per-product validation: each product must have name, date, proj, res
    for pid, pobj in state["products"].items():
        if not isinstance(pobj, dict):
            raise ValueError(f"Product '{pid}' must be an object.")
        for k in ("name", "date", "proj", "res"):
            if k not in pobj:
                raise ValueError(f"Product '{pid}' missing '{k}'.")
        if not isinstance(pobj["name"], str):
            raise ValueError(f"Product '{pid}'.name must be a string.")
        if not isinstance(pobj["proj"], str):
            raise ValueError(f"Product '{pid}'.proj must be a string.")
        if not (isinstance(pobj["res"], (int, float)) or pobj["res"] == "NaN"):
            raise ValueError(f"Product '{pid}'.res must be a float or 'NaN'.")
        if not isinstance(pobj["date"], dict):
            raise ValueError(f"Product '{pid}'.date must be a dict.")

    return state


# -------------------------------
# ----- Geoprocessing Logic -----
# -------------------------------

def geoprocess(json_instructions) -> None:
    pass

# ----------------
# ----- Main -----
# ----------------

def main(msg: str) -> None:
    print("Entered Geoprocessing Mode... Not yet implemented.")
    
    json_instructions = complete_json(msg)
    
    print("Final JSON instructions:")
    print(json.dumps(json_instructions, ensure_ascii=False, indent=2))

    geoprocess(json_instructions)