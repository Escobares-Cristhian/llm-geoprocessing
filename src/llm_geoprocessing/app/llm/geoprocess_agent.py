import json
import re
from typing import Dict, Any, List, Optional

from llm_geoprocessing.app.chatbot.chatbot import Chatbot
from llm_geoprocessing.app.plugins.preprocessing_plugin import get_metadata_preprocessing, get_documentation_preprocessing
from llm_geoprocessing.app.plugins.geoprocessing_plugin import get_metadata_geoprocessing, get_documentation_geoprocessing

    
# ---------------------------------
# ----- JSON Completion Logic -----
# ---------------------------------

def _plugin_instructions() -> str:
    # Information about available data and preprocessing
    data_metadata = get_metadata_preprocessing()
    data_docs = get_documentation_preprocessing()
    
    # Information about geoprocessing capabilities
    geoprocess_metadata = get_metadata_geoprocessing()
    geoprocess_docs = get_documentation_geoprocessing()
    
    # Combine to get instructions to append to the schema instructions
    plugin_instructions = (
        "Available Data and Preprocessing Options:\n"
        f"{data_metadata}\n"
        f"{data_docs}\n\n"
        "Geoprocessing Capabilities:\n"
        f"{geoprocess_metadata}\n"
        f"{geoprocess_docs}\n\n"
        f"General Notes:\n"
        "- If a geoprocess is requested, and do not have all required data or geoprocessing capabilities, list precise questions in 'questions'.\n"
        "- Do not assume availability of any data or capability that is not explicitly mentioned in 'Available Data and Preprocessing Options' or 'Geoprocessing Capabilities'.\n"
    )
    return plugin_instructions

def _schema_instructions() -> str:
    # Strict schema + rules (concise)
    schema = (
        "Return ONLY a JSON wrapper with keys: 'json', 'complete', 'questions'.\n"
        "- 'json' keys:\n"
        "  1) 'products': object mapping product ('A','B',...) to objects with:\n"
        "     - order of the product 'A' is the first, 'B' the second, etc, only referred to the order of each item in the 'products' object.\n"
        "     - 'name': string (full product path, must be a file, not a folder).\n"
        "     - 'date': {'initial_date':'YYYY-MM-DD','end_date':'YYYY-MM-DD',"
        "     - 'proj': string (use 'default' to keep original).\n"
        "     - 'res': float OR the string 'NaN' to keep original.\n"
        "  2) 'actions': list of 2-item lists, each 2-item list with format [<geoprocess name>, <input to geoprocess>]."
        "     <geoprocess name> is one of the available geoprocessing functions listed in 'Geoprocessing Capabilities'."
        "     <input to geoprocess> is a JSON object with the required parameters for that geoprocessing function, can be empty {} if no parameters are needed."
        "     If no geoprocessing is requested, use an empty list []."
        "     If multiple geoprocesses are requested or needed, list them in order.\n"
        "  3) 'other_params': dict (can be {})."
        "     Global parameters for the Geoprocessing Capabilities."
        "     If no global parameters are needed, use an empty object {}."
        "     If no global parameters are specified in the Geoprocessing Capabilities, use an empty object {}.\n"
        "Never invent values. If unknown, leave missing and add precise questions.\n"
        "Wrapper format:\n"
        "{ 'json': {...}, 'complete': true|false, 'questions': ['Q1','Q2',...] }\n"
    )
    
    return _plugin_instructions() + "\n\n" + schema


def _sanitize_json(raw: str) -> str:
    # Replace bare NaN -> "NaN"; remove trailing commas
    s = re.sub(r'(?<!\")\bNaN\b(?!\")', '"NaN"', raw)
    s = re.sub(r",\s*([}\]])", r"\1", s)
    return s


def _extract_first_json_block(text: str) -> Optional[Dict[str, Any]]:
    # Prefer fenced code blocks
    blocks = re.findall(r"```(?:json)?\s*(\{[\s\S]*?\})\s*```", text, flags=re.IGNORECASE)
    if not blocks:
        blocks = re.findall(r"(\{[\s\S]*\})", text)
    for b in blocks:
        try:
            return json.loads(_sanitize_json(b))
        except Exception:
            continue
    return None


def complete_json(chatbot: Chatbot, user_message: str) -> Dict[str, Any]:
    """
    Build the target JSON by dialog with the user via the LLM.
    - Input: chatbot instance and single pre-processed message (string).
    - Flow: extract -> if missing, ask -> update -> repeat.
    - Output: Python dict with the requested schema.
    - All user-facing messages are generated by the LLM (printed).
    """
    chat = chatbot.clone()
    MAX_TURNS = 8  # tiny safety to avoid infinite loops

    # 1) Ask LLM to extract from the initial message
    prompt = (
        "Task: Extract everything you can from the user's message into the schema. "
        "List only the truly missing items as questions.\n\n"
        f"User message:\n{user_message}\n\n{_schema_instructions()}"
    )
    reply = chat.send_message(prompt)
    wrapper = _extract_first_json_block(reply)
    if not wrapper or not all(k in wrapper for k in ("json", "complete", "questions")):
        raise ValueError("LLM did not return a valid wrapper JSON on first pass.")

    state: Dict[str, Any] = wrapper["json"]
    complete: bool = bool(wrapper["complete"])
    questions: List[str] = list(wrapper.get("questions", []))

    # 2) If incomplete, iterate: ask -> wait -> update
    turns = 0
    while not complete and turns < MAX_TURNS:
        turns += 1

        # LLM composes the concise questions to show the user
        q_prompt = (
            "Compose a single concise message asking ONLY these questions, nothing else.\n"
            + "\n".join(f"{i+1}. {q}" for i, q in enumerate(questions))
            + "\n Respond in the same language as the user."
        )
        q_msg = chat.send_message(q_prompt)
        print(f"{chat.chat.__class__.__name__}: {q_msg}") # show LLM's question to the user

        user_answer = input("You: ").strip()
        if user_answer.lower() in {"exit", "quit"}:
            raise KeyboardInterrupt("User aborted.")

        # Ask LLM to update the JSON with the user's answers
        update_prompt = (
            "Update the JSON with the user's answers. Keep confirmed fields. "
            "Ask follow-ups only if still missing.\n"
            "Do not assume information except when the user ask to assume, or when the user is clearly a non expert.\n\n"
            f"Current JSON:\n```json\n{json.dumps(state, ensure_ascii=False)}\n```\n\n"
            f"User reply:\n{user_answer}\n\n{_schema_instructions()}"
        )
        reply = chat.send_message(update_prompt)
        wrapper = _extract_first_json_block(reply)
        if not wrapper or not all(k in wrapper for k in ("json", "complete", "questions")):
            raise ValueError("LLM did not return a valid wrapper JSON during update.")

        state = wrapper["json"]
        complete = bool(wrapper["complete"])
        questions = list(wrapper.get("questions", []))

    # 3) Minimal shape checks (simple and strict)
    required = ["products", "actions", "other_params"]  # per-product date/proj/res now nested
    if not all(k in state for k in required):
        raise ValueError("Final JSON missing required keys.")
    if not isinstance(state["products"], dict):
        raise ValueError("'products' must be a dict.")
    if not isinstance(state["actions"], list):
        raise ValueError("'actions' must be a list.")
    if not isinstance(state["other_params"], dict):
        raise ValueError("'other_params' must be a dict.")

    # Per-product validation: each product must have name, date, proj, res
    for pid, pobj in state["products"].items():
        if not isinstance(pobj, dict):
            raise ValueError(f"Product '{pid}' must be an object.")
        for k in ("name", "date", "proj", "res"):
            if k not in pobj:
                raise ValueError(f"Product '{pid}' missing '{k}'.")
        if not isinstance(pobj["name"], str):
            raise ValueError(f"Product '{pid}'.name must be a string.")
        if not isinstance(pobj["proj"], str):
            raise ValueError(f"Product '{pid}'.proj must be a string.")
        if not (isinstance(pobj["res"], (int, float)) or pobj["res"] == "NaN"):
            raise ValueError(f"Product '{pid}'.res must be a float or 'NaN'.")
        if not isinstance(pobj["date"], dict):
            raise ValueError(f"Product '{pid}'.date must be a dict.")

    return state


# -------------------------------
# ----- Geoprocessing Logic -----
# -------------------------------

def geoprocess(json_instructions) -> str:
    #TODO: DUMMY FUNCTION
    return f"Here is the JSON instructions generated, assume this was processed: {json.dumps(json_instructions)}"

# ----------------
# ----- Main -----
# ----------------

def main(chatbot: Chatbot, msg: str) -> Optional[str]:
    print("Entered Geoprocessing Mode...")
    
    json_instructions = complete_json(chatbot, msg)
    
    print("Final JSON instructions:")
    print(json.dumps(json_instructions, ensure_ascii=False, indent=2))

    msg_to_interpreter = geoprocess(json_instructions)
    
    return msg_to_interpreter